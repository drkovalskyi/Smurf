#include "tauify.h"
#include "Math/EulerAngles.h"
#include "TMath.h"

void PrintP4(LorentzVector p3){
  cout << p3.Px() << " " << p3.Py() << " " << p3.Pz() << endl;
}
void PrintP3(Vector p3){
  cout << p3.X() << " " << p3.Y() << " " << p3.Z() << endl;
}


/////////////////////////////////////////////////////////////////////////////
// Return a Random 3 Momenta in the Plane Normal to a Given Unit 3 Momenta //
/////////////////////////////////////////////////////////////////////////////

Vector TauData::GetRandomNormalVector( Vector p3_normal ){

  /////////////////////////
  // Input Normal Vector //
  /////////////////////////

  p3_normal /= sqrt( p3_normal.Mag2() );


  /////////////////////////
  // Random Euler Angles //
  /////////////////////////

  double phi   = randA_->Uniform( 0.0, 2*TMath::Pi() );
  double theta = randA_->Uniform( 0.0, TMath::Pi() );
  double psi   = randA_->Uniform( 0.0, 2*TMath::Pi() );


  ///////////////////////////////////////////////////////////  
  // Random 3 Momenta Generated by a Random Euler Rotation //
  ///////////////////////////////////////////////////////////

  ROOT::Math::EulerAngles euler(phi, theta, psi);
  Vector p3_cross = euler( p3_normal );


  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Get a Random 3 Momenta in the Normal Plane by Crossing the Input Normal with a Random 3 Momenta //
  ////////////////////////////////////////////////////////////////////////////////////////////////////

  Vector p3_perp  = p3_cross.Cross( p3_normal );
  p3_perp        /= sqrt( p3_perp.Mag2() );


  ////////////
  // Sanity //
  ////////////
  
  double eps = 1e-6;
  double dot = p3_perp.Dot( p3_normal );
  if ( fabs( 0.0 - dot ) > eps ){
    cout << "Euler ERROR: " << setprecision(10) << dot << endl;
    exit(1);
  }


  //////////
  // Done //
  //////////

  return p3_perp;

}


//////////////////
// Tauification //
//////////////////

void TauData::DecayAsTau( LorentzVector p4_tau ) {
  
/////////////////
// Monte Carlo //
/////////////////

  //////////////////////////////////////////////////////////////////
  // Get x = E/Emax and y = cos(theta)                            //
  // From ( d^2 Sigma / dx dy ) for Tau -> Lep + NuLepBar + NuTau //
  //////////////////////////////////////////////////////////////////

  double x; // x = E/Emax
  double y; // y = cos(theta)
  double z;
  double f;
  bool  accept = false;
  while( accept == false ){

    //  
    double xrand = rand3_->Rndm(); // x = E/Emax
    double yrand = rand3_->Rndm(); // y = cos(theta)
    double zrand = rand3_->Rndm(); // z = f(x,y)

    //
    x = xmin_ + xrand*( xmax_ - xmin_ );
    y = ymin_ + yrand*( ymax_ - ymin_ );
    z = zrand*fmax_;
    f = x*x*( 3 - 2*x + ( (double)polarization_sign_ )*( 2*x - 1 )*y );

    // Use x, y
    if( z < f ){
      accept = true;
    };

  }

  // x and y are now determined
  h2_xy_->Fill( x, y );

/////////////////////
// End Monte Carlo //
/////////////////////


  
//////////////////////////////////////////////////////////
// Get the 4-Vector of the Lepton in the Tau Rest Frame //
//////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////
  // Theta is the Angle Between the Lepton in the CM Frame and the Tau in the LAB Frame //
  ////////////////////////////////////////////////////////////////////////////////////////

  double cosTheta = y;
  double sinTheta = sqrt(1-cosTheta*cosTheta);


  ///////////////////////
  // Declare 3 vectors //
  ///////////////////////

  Vector p3_lab;
  Vector p3_lab_unit;
  Vector p3_cm;
  Vector p3_cm_para;
  Vector p3_cm_perp;
  Vector p3_cross;


  ///////////////////////
  // Declare 4 vectors //
  ///////////////////////

  p4d p4_cm;
  p4d p4_cm_para;
  p4d p4_cm_perp;


  /////////////////////////////////////////////////////////////////////////
  // Determine the Energy and Momentum of the Lepton in the Tau CM Frame //
  /////////////////////////////////////////////////////////////////////////

  //---------------------------------------------------//
  // Need to think about how to properly handle masses //
  //---------------------------------------------------//

  //double M = m_mu_;       

  // static const double W_tau_mu = ( ( pow( m_tau_, 2 ) + pow( m_mu_, 2 ) ) / ( 2*m_tau_ ) );
  // static const double W_tau_el = ( ( pow( m_tau_, 2 ) + pow( m_el_, 2 ) ) / ( 2*m_tau_ ) );

  const double W_tau_mu = 0.5*m_tau_;  // Massless Mu Approximation
  const double W_tau_el = 0.5*m_tau_;  // Massless El Approcimation

  //-------------------------------//
  // This is where E and P are Set //
  //-------------------------------//

  double E = x * W_tau_mu;
  //double P = sqrt( pow(E,2) - pow(M,2) );
  double P = E;


  ///////////////////////////////////////////////////
  // Unit 3 Momenta of the Lepton in the LAB Frame //
  ///////////////////////////////////////////////////

  p3_lab.SetCoordinates( p4_tau.Px(), p4_tau.Py(), p4_tau.Pz() );
  p3_lab_unit = p3_lab / sqrt( p3_lab.mag2() );


  ////////////////////////////////////////////////////////////////////////////////////////////
  // 3 Momenta of the Lepton in the CM Frame Paralell to the Tau Direction in the LAB Frame //
  ////////////////////////////////////////////////////////////////////////////////////////////

  p3_cm_para = p3_lab_unit;
  p3_cm_para *= P * cosTheta; 


  /////////////////////////////////////////////////////////////////////////////////////////////////
  // 3 Momenta of the Lepton in the CM Frame Perpendicular to the Tau Direction in the LAB Frame //
  /////////////////////////////////////////////////////////////////////////////////////////////////

  p3_cm_perp      = GetRandomNormalVector( p3_lab_unit );
  p3_cm_perp     /= sqrt( p3_cm_perp.mag2() );
  p3_cm_perp     *= P * sinTheta;


  /////////////////////////////////////////////
  // 4 Momenta of the Lepton in the CM Frame //
  /////////////////////////////////////////////

  //p3_cm = p3_cm_perp;
  p3_cm = p3_cm_para + p3_cm_perp;
  p4_cm.SetPxPyPzE( p3_cm.X(), p3_cm.Y(), p3_cm.Z(), E );

  // cos(Theta) in the CM Frame
  cosThetaCM_ = p4_cm.Px()*p4_tau.Px() + p4_cm.Py()*p4_tau.Py() + p4_cm.Pz()*p4_tau.Pz();
  cosThetaCM_ /= ( sqrt( pow(p4_cm.Px(),2) + pow(p4_cm.Py(),2) + pow(p4_cm.Pz(),2) ) * sqrt( pow(p4_tau.Px(),2) + pow(p4_tau.Py(),2) + pow(p4_tau.Pz(),2) ) );

  ////////////
  // Sanity //
  ////////////

  int    pre = 6;
  double eps = pow(10,-1*pre);

  // Check p3_cm_para is parallel to p3_lab 
  double cosThetaTest =  p3_cm_para.Dot( p3_lab ) / sqrt(  p3_cm_para.Mag2() * p3_lab.Mag2() );
  if( ( 1.0 - fabs(cosThetaTest) )  > eps ) {
    cout << "ERROR: Inner Product of p3_cm_para and p3_lab != 1" << endl;
    cout << setprecision(pre+2) << cosThetaTest << endl;
    exit(1);
  }

  // Check p3_cm_perp is perpendicular to p3_lab
  cosThetaTest =  p3_cm_perp.Dot( p3_lab ) / sqrt(  p3_cm_perp.Mag2() * p3_lab.Mag2() );
  if( cosThetaTest > eps ) {
    cout << "ERROR: Inner Product of p3_cm_perp and p3_lab != 0" << endl;
    cout << setprecision(pre+2) << cosThetaTest << endl;
    exit(1);
  }

  // Check that the CM Energy is what it should be
  if( fabs( 1.0 - ( p4_cm.E() / E ) ) > pow(10,-9) ) {
    cout << "ERROR: Bad Center of Mass Energy:" << endl;
    cout << " -> " << setprecision(pre+2) << p4_cm.E() << " != " << E << endl << endl;
    exit(1);
  }
  
  // Check that the CM Momentum is what it should be
  if( fabs( 1.0 - ( p4_cm.P() / P ) ) > pow(10,-9) ) {
    cout << "ERROR: Bad Center of Mass Momentum" << endl;
    cout << " -> " << setprecision(pre+2) << p4_cm.P() << " != " << P << endl << endl;
    exit(1);
  }

  // Check that p4_CM has the right cos(Theta)
  cosThetaTest = cosThetaCM_;
  if( fabs( 1.0 - ( cosThetaTest / cosTheta ) ) > pow(10,-6) ) {
    cout << "ERROR: " << endl;
    cout << " -> " << setprecision(pre+2) <<  cosThetaTest << " != " << cosTheta << endl << endl;
    exit(1);
  }


  ////////////////
  // End Sanity //
  ////////////////


  //////////
  // Done //
  //////////

  //
  p4_lep_CM_.SetPxPyPzE( (float)p4_cm.Px(), (float)p4_cm.Py(), (float)p4_cm.Pz(), (float)p4_cm.E() );

}

//////////////////
// Tauification //
//////////////////

bool TauData::Tauify( LorentzVector p4_tau, int sign ) {
 
      //
      bool success       = true;  // Return Value
      polarization_sign_ = sign;  // Assing Polarization
      if( polarization_sign_ != 0 ){
        //cout << "Non-zero Polarization not Validated... Exiting." << endl;
        //exit(1);
      }

      //////////////////////////////////
      // Boost to the Lepton CM Frame //
      //////////////////////////////////

      boost_CM_.SetComponents( p4_tau.BoostToCM().x(), p4_tau.BoostToCM().y(), p4_tau.BoostToCM().z() );
      p4_lep_CM_ = boost_CM_ * p4_tau;

    
      //////////////////////////////////////////////
      // Decay the Lepton As Though it Were a Tau //
      //////////////////////////////////////////////

      DecayAsTau( p4_tau );


      /////////////////////////////////
      // Boost Back to the LAB Frame //
      /////////////////////////////////

      boost_LAB_ = boost_CM_.Inverse(); 
      LorentzVector p4_lep_LAB = boost_LAB_ * p4_lep_CM_;


      /////////////////////////////////////////////////////////////////////////
      // Cosine of the Angle between the Tau and the Lepton in the LAB Frame //
      /////////////////////////////////////////////////////////////////////////

      cosThetaLAB_ = p4_lep_LAB.Px()*p4_tau.Px() + p4_lep_LAB.Py()*p4_tau.Py() + p4_lep_LAB.Pz()*p4_tau.Pz();
      cosThetaLAB_ /= sqrt( ( pow(p4_lep_LAB.Px(),2) + pow(p4_lep_LAB.Py(),2) + pow(p4_lep_LAB.Pz(),2) )*( pow(p4_tau.Px(),2) + pow(p4_tau.Py(),2) + pow(p4_tau.Pz(),2) ) );


      ////////////
      // Sanity //
      ////////////

      /*
      // This was to check that boosting to the CM and back worked     
      cout.flags( ios::fixed );
      cout.precision(1);
      cout.width(20);
      float w = 10;
 
      //
      bool debug = false;
      if( debug ){
        if( p4_lep_CM_.P() > 1.0 ) { // Momentum Should be 0 in CM_ Frame
          success = false;
          cout << "WARNING Non-Zero CM momenta: " << endl;
          cout << "     ( E, P, Pt, Px, Py, Pz, Eta, Phi, M, M2 ) = ( " 
               << setw(w) << p4_lep_CM_.E()   << ", " 
               << setw(w) << p4_lep_CM_.P()   << ", "
               << setw(w) << p4_lep_CM_.Pt()  << ", "
               << setw(w) << p4_lep_CM_.Px()  << ", "
               << setw(w) << p4_lep_CM_.Py()  << ", "
               << setw(w) << p4_lep_CM_.Pz()  << ", "
               << setw(w) << p4_lep_CM_.Eta() << ", "
               << setw(w) << p4_lep_CM_.Phi() << ", "
               << setw(w) << p4_lep_CM_.M()   << ","
               << setw(w) << p4_lep_CM_.M2()  << ") "
               << endl << endl;
        }
        if( fabs( p4_lep_LAB.pt() - p4_tau.pt() ) > .01 ) {
          success = false;
          cout << "WARNING p4_LAB != boost_LAB * boost_CM * p4_LAB: " << endl;
          cout << "     p4  = ( " << p4_tau.pt()     << ", " << p4_tau.eta()     << ", " << p4_tau.phi()     << ", " << p4_tau.mass()     << " )" << endl;
          cout << "     p4' = ( " << p4_lep_LAB.pt() << ", " << p4_lep_LAB.eta() << ", " << p4_lep_LAB.phi() << ", " << p4_lep_LAB.mass() << " )" << endl;
          cout << " ------------------------------------------------------------------------------------------------------------------------------------- " << endl << endl;
        }
      }
      */

      /////////////////////////
      // Assign Data Members //
      /////////////////////////

      p4_lep_ = p4_lep_LAB; 
      p4_met_ = p4_tau - p4_lep_;


      //////////
      // Done //
      //////////

      return success;

}
